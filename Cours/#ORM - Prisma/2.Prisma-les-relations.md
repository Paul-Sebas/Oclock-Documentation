# Prisma - Focus sur les relations

Les **relations**, c'est LE point clÃ© oÃ¹ Prisma se distingue vraiment des autres ORM. Prisma gÃ¨re les relations de maniÃ¨re trÃ¨s intuitive et puissante, grÃ¢ce Ã  son systÃ¨me de **modÃ¨les** et de **champs relationnels**.

---

## Focus dÃ©taillÃ© sur les relations avec Prisma ORM

ğŸ“˜ Docs principales utilisÃ©es dans cette section :

<https://www.prisma.io/docs/orm/prisma-schema/relations>

<https://www.prisma.io/docs/orm/prisma-schema/relations/relation-fields>

<https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries>

---

## 1. Rappel conceptuel : câ€™est quoi une relation ?

En base relationnelle :

- une clÃ© Ã©trangÃ¨re
- qui relie deux tables
- avec une cardinalitÃ© :
  - 1-1 (One-to-One)
  - 1-N (One-to-Many)
  - N-N (Many-to-Many)

ğŸ‘‰ Prisma ne â€œdevineâ€ rien :

tu dÃ©clares explicitement la relation des deux cÃ´tÃ©s.

---

## 2. DiffÃ©rence clÃ© avec Sequelize (IMPORTANT)

### Sequelize (rappel mental)

```ts
User.hasMany(Post)
Post.belongsTo(User)
```

- relation dÃ©clarÃ©e en JS --> pas dans le schÃ©ma
- souvent implicite --> pas de typage fort
- typage fragile --> pas de garantie Ã  la compilation

---

### Prisma

```prisma
model User {
  posts Post[]
}

model Post {
  user   User @relation(fields: [userId], references: [id])
  userId Int
}
```

ğŸ‘‰ Prisma veut :

- le **champ relation**

- le **champ clÃ© Ã©trangÃ¨re**

- le **lien explicite entre les deux**

ğŸ¯ Objectif : **zÃ©ro ambiguÃ¯tÃ©**.

---

## 3. Relation One-to-Many (1-N)

### Exemple : User --> Post

ğŸ“˜ Cas le plus courant

---

### 3.1 Le modÃ¨le complet

```prisma
model User {
  id    Int    @id @default(autoincrement())
  email String @unique

  posts Post[]   // 1 User â†’ plusieurs Posts
}

model Post {
  id     Int    @id @default(autoincrement())
  title  String

  userId Int
  user   User   @relation(fields: [userId], references: [id])
}
```

---

### 3.2 Lecture ligne par ligne

#### CotÃ© `User`

```prisma
posts Post[]
```

â¡ï¸ champ virtuel (pas une colonne SQL)

â¡ï¸ reprÃ©sente la relation inverse

---

#### CotÃ© `Post`

```prisma
userId Int
```

â¡ï¸ vraie colonne SQL (clÃ© Ã©trangÃ¨re)

```prisma
user User @relation(fields: [userId], references: [id])
```

â¡ï¸ dit Ã  Prisma :

- `userId` pointe vers

- `User.id`

---

### 3.3 Ce que Prisma gÃ©nÃ¨re en DB

```sql
userId INTEGER REFERENCES "User"(id)
```

â¡ï¸ Prisma respecte strictement SQL.

---

## 4. Utiliser une relation en lecture

ğŸ“˜ Doc :

<https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries>

```ts
const users = await prisma.user.findMany({
  include: {
    posts: true
  }
})
```

â¡ï¸ RÃ©sultat :

```ts
User & { posts: Post[] }
```

ğŸ’¡ Typage automatique :

TypeScript sait que posts existe.

---

## 5. CrÃ©er des donnÃ©es liÃ©es (nested writes)

### 5.1 CrÃ©er un User avec des Pots

```ts
await prisma.user.create({
  data: {
    email: "alice@mail.com",
    posts: {
      create: [
        { title: "Post 1" },
        { title: "Post 2" }
      ]
    }
  }
})
```

ğŸ‘‰ Prisma :

- crÃ©e le User
- rÃ©cupÃ¨re son id
- lâ€™injecte dans les Posts

â¡ï¸ Pas de transaction manuelle Ã  Ã©crire.

---

### Sequelize vs Prisma (mental)

### 1. Sequelize

- `User.create()`
- puis `Post.create()`
- gÃ©rer les IDs

### 2. Prisma

- relation dÃ©clarative

---

## 6. Relation One-to-One (1-1)

### Exemple : User <--> Profile

---

### 6.1 ModÃ¨le

```prisma
model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  profile Profile?
}

model Profile {
  id     Int   @id @default(autoincrement())
  bio    String
  userId Int   @unique
  user   User  @relation(fields: [userId], references: [id])
}
```

---

### 6.2 Points importants

- `Profile.userId` est `@unique`
- relation **optionnelle** cÃ´tÃ© User (`Profile?`)
- clÃ© Ã©trangÃ¨re **dâ€™un seul cÃ´tÃ©**

ğŸ‘‰ Prisma impose une structure propre et lisible.

---

## 7. Relation Many-to-Many (N-N)

ğŸ“˜ Doc :

<https://www.prisma.io/docs/orm/prisma-schema/relations/many-to-many-relations>

### 7.1 Many-to-Many implicite (le plus simple)

```prisma
model Post {
  id    Int    @id @default(autoincrement())
  tags  Tag[]
}

model Tag {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

â¡ï¸ Prisma crÃ©e **automatiquement une table de liaison**.

ğŸ§  TrÃ¨s pratique pour lâ€™apprentissage.

---

### 7.2 Many-to-Many explicite (plus de contrÃ´le)

```prisma
model Post {
  id    Int    @id @default(autoincrement())
  tags  PostTag[]
}

model Tag {
  id    Int    @id @default(autoincrement())
  posts PostTag[]
}

model PostTag {
  postId Int
  tagId  Int

  post Post @relation(fields: [postId], references: [id])
  tag  Tag  @relation(fields: [tagId], references: [id])

  @@id([postId, tagId])
}
```

â¡ï¸ On gÃ¨re la table de liaison nous-mÃªmes.

ğŸ‘‰ utile si :

- champs supplÃ©mentaires
- contraintes custom

---

## 8. Filtrer via les relations

```ts
await prisma.user.findMany({
  where: {
    posts: {
      some: {
        title: { contains: "Prisma" }
      }
    }
  }
})
```

â¡ï¸ Prisma permet de filtrer facilement sur les relations.

â¡ï¸ Lisible, expressif, typÃ©.

---

## 9. Supprimer et contraintes (delete)

### Par dÃ©faut

- Prisma empÃªche les suppressions dangereuses
- respecte les contraintes SQL

### Optionnel : cascade

```prisma
@relation(
  fields: [userId],
  references: [id],
  onDelete: Cascade
)
```

âš ï¸ Ã€ utiliser consciemment.

---

## 10. Bonne pratiques spÃ©cifiques aux relations

âœ… Toujours nommer clairement les champs (userId, postId)

âœ… Lire la relation des deux cÃ´tÃ©s

âœ… Commencer simple (1-N)

âœ… Ã‰viter le N-N explicite trop tÃ´t

âœ… Sâ€™appuyer sur le typage TS pour comprendre les retours

---

## ğŸ§  RÃ©sumÃ© mental ultra important

Prisma ne fait **aucune magie**

ğŸ‘‰ Tout est **dÃ©clarÃ©**, **explicite** et **typÃ©**
