# Les erreurs classiques avec Prisma

Les **erreurs sur les relations**, câ€™est exactement lÃ  oÃ¹ Prisma est le plus formateurâ€¦ et parfois le plus frustrant au dÃ©but. Bonne nouvelle : **elles sont trÃ¨s cohÃ©rentes** une fois que l'on comprend la logique.

On va voir les erreurs les plus courantes, pourquoi elles arrivent, et comment les Ã©viter, avec des parallÃ¨les Sequelize quand Ã§a aide.

---

## âŒ Erreurs classiques avec les relations Prisma ORM

(et comment les Ã©viter)

ğŸ“˜ Docs utiles en arriÃ¨re-plan :

<https://www.prisma.io/docs/orm/prisma-schema/relations>

<https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries>

---

## 1. Oublier le champ clÃ© Ã©trangÃ¨re (foreign key)

### âŒ Erreur typique

```prisma
model Post {
  id    Int   @id @default(autoincrement())
  title String
  user  User
}
```

### ğŸ§¨ ProblÃ¨me

- Prisma **ne sait pas** oÃ¹ stocker la relation
- Pas de clÃ© Ã©trangÃ¨re dÃ©clarÃ©e
- AmbiguÃ¯tÃ© totale cÃ´tÃ© DB

### âœ… Correction

```prisma
model Post {
  id     Int  @id @default(autoincrement())
  title  String
  userId Int
  user   User @relation(fields: [userId], references: [id])
}
```

- On dÃ©clare explicitement `userId` comme clÃ© Ã©trangÃ¨re
- On indique Ã  Prisma comment la relation est structurÃ©e
- RÃ©sultat : un schÃ©ma clair et une base de donnÃ©es cohÃ©rente

### ğŸ§  RÃ¨gle dâ€™or

Toute relation a besoin dâ€™un champ SQL rÃ©el quelque part.

---

## 2. Mettre `@relation` des deux cotÃ©s

### âŒ Erreur frÃ©quente

```prisma
model User {
  posts Post[] @relation(...)
}

model Post {
  user User @relation(...)
}
```

### ğŸ§¨ ProblÃ¨me

- Prisma ne sait pas quel cotÃ© possÃ¨de la clÃ© Ã©trangÃ¨re
- Relation sur-dÃ©finie --> conflit de schÃ©ma

### âœ… RÃ¨gle correcte

- `@relation(fields, references)` **uniquement du cÃ´tÃ© avec la FK**
- lâ€™autre cÃ´tÃ© est **dÃ©claratif** uniquement

---

## 3. Types incompatibles entre clÃ© primaire et clÃ© Ã©trangÃ¨re

### âŒ Exemple

```prisma
model User {
  id String @id @default(uuid())
}

model Post {
  userId Int
  user   User @relation(fields: [userId], references: [id])
}
```

### ğŸ§¨ Erreur Prisma

> Type mismatch between `userId` and referenced field `id`

### âœ… Correction

```prisma
model Post {
  userId String  // <-- doit Ãªtre du mÃªme type que User.id
  user   User @relation(fields: [userId], references: [id])
}
```

ğŸ§  Prisma est **trÃ¨s strict**, mais câ€™est une sÃ©curitÃ© Ã©norme.

---

## 4. Relation optionnelle mal dÃ©clarÃ©e

### âŒ Cas frÃ©quent

```prisma
model Post {
  userId Int
  user   User?
}
```

### ğŸ§¨ IncohÃ©rence

- `user?` --> relation optionnelle
- `userId Int` --> obligatoire

### âœ… Les deux doivent Ãªtre cohÃ©rents

```prisma
model Post {
  userId Int?
  user   User?
}
```

ou

```prisma
model Post {
  userId Int
  user   User
}
```

- les deux sont soit optionnels, soit obligatoires

ğŸ§  Optionnel = optionnel **partout**.

---

## 5. Oublier `@unique` sur une relation One-to-One

### âŒ Erreur classique

```prisma
model Profile {
  userId Int
  user   User @relation(fields: [userId], references: [id])
}
```

### ğŸ§¨ ProblÃ¨me

- Prisma considÃ¨re que plusieurs `Profile` peuvent pointer vers `User`
- Ce n'est **plus du 1-1**

### âœ… Correction

```prisma
model Profile {
  userId Int @unique
  user   User @relation(fields: [userId], references: [id])
}
```

ğŸ‘‰ En SQL :

@unique = contrainte dâ€™unicitÃ©.

---

## 6. Croire que le champ relation est une colonne SQL

### âŒ Mauvaise intuition

```prisma
model Post {
  user User
}
```

> "Prisma va crÃ©er une colonne `user` dans la table `Post`"

âŒ Faux.

#### ğŸ§  RÃ©alitÃ©

- `user` â†’ champ virtuel
- `userId` â†’ colonne rÃ©elle

ğŸ‘‰ TrÃ¨s diffÃ©rent de Sequelize oÃ¹ tout est plus flou.

---

## 7. Essayer d'Ã©crire une relation sans `connect` ou `create`

### âŒ Exemple

```ts
await prisma.post.create({
  data: {
    title: "Hello",
    userId: 1
  }
})
```

ğŸŸ¡ Parfois valide, maisâ€¦

### âŒ Erreur plus frÃ©quente

```ts
data: {
  title: "Hello",
  user: 1
}
```

### âœ… Correct

```ts
data: {
  title: "Hello",
  user: {
    connect: { id: 1 }
  }
}
```

ğŸ§  Prisma veut une **intention explicite** :

- `connect` â†’ lier Ã  un enregistrement existant
- `create` â†’ crÃ©er un nouvel enregistrement liÃ©
- `disconnect` â†’ dÃ©connecter la relation

---

## 8. Ne pas utiliser `include` et croire que la relation est lÃ 

### âŒ Surprise frÃ©quente

```ts
const user = await prisma.user.findUnique({
  where: { id: 1 }
})

console.log(user.posts) // undefined
```

#### ğŸ§¨ Pourquoi ?

- Prisma ne charge rien par dÃ©faut
- performance > magie

#### âœ… Correct

```ts
const user = await prisma.user.findUnique({
  where: { id: 1 },
  include: { posts: true }
})
```

---

## 9. Supprimer un parent sans gÃ©rer les enfants

### âŒ Cas

```ts
await prisma.user.delete({ where: { id: 1 } })
```

#### ğŸ§¨ Erreur SQL

> Foreign key constraint failed

#### âœ… Solutions

1. Supprimer les enfants avant
2. Utiliser `onDelete: Cascade` dans le schÃ©ma
3. Rendre la relation optionnelle

ğŸ‘‰ Prisma protÃ¨ge **par dÃ©faut**.

---

## 10. Penser Prisma comme Sequelize

### âŒ Mauvaise approche

> "Prisma va deviner mes relations comme Sequelize"

### âœ… Bonne approche

> Â« Je dÃ©cris exactement mon modÃ¨le relationnel Â»

ğŸ§  Prisma te force Ã  **penser base de donnÃ©es**, pas ORM magique.

---

## ğŸ§  Anti-checklist mentale avant migration

Avant `prisma migrate` :

- â“ OÃ¹ est la clÃ© Ã©trangÃ¨re ?
- â“ Est-ce optionnel partout ?
- â“ Les types correspondent ?
- â“ 1-1 â†’ `@unique` ?
- â“ Ai-je vraiment besoin du N-N explicite ?

---

## En rÃ©sumÃ©

> Les erreur Prisma ne sont pas des bugs
>
> ğŸ‘‰ ce sont des ***garde-fous pÃ©dagogiques***
